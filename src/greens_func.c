#include "greens_func.h"
#include <mkl.h>
#include <math.h>
#include <stdlib.h>
#include <memory.h>


//________________________________________________________________________________________________________________________
///
/// \brief Construct the Green's function matrix (I + A)^{-1} with A the imaginary-time flow map
///
/// References:
///   - S. R. White, D. J. Scalapino, R. L. Sugar, E. Y. Loh, J. E. Gubernatis, R. T. Scalettar\n
///     Numerical study of the two-dimensional Hubbard model\n
///     Phys. Rev. B 40, 506 (1989)
///   - Z. Bai, C.-R. Lee, R.-C. Li, S. Xu\n
///     Stable solutions of linear systems involving long chain of matrix multiplications\n
///     Linear Algebra Appl. 435, 659-673 (2011)
///
void GreenConstruct(const time_step_matrices_t *restrict tsm, const int slice_shift, double *restrict G)
{
	const int N = tsm->N;

	// allocate memory for time flow map
	double *Q   = (double *)MKL_malloc(N*N * sizeof(double), MEM_DATA_ALIGN);
	double *tau = (double *)MKL_malloc(N   * sizeof(double), MEM_DATA_ALIGN);	// scalar factors of the elementary reflectors for the matrix Q
	double *d   = (double *)MKL_malloc(N   * sizeof(double), MEM_DATA_ALIGN);
	double *T   = (double *)MKL_malloc(N*N * sizeof(double), MEM_DATA_ALIGN);
	__assume_aligned(Q,   MEM_DATA_ALIGN);
	__assume_aligned(tau, MEM_DATA_ALIGN);
	__assume_aligned(d,   MEM_DATA_ALIGN);
	__assume_aligned(T,   MEM_DATA_ALIGN);

	// calculate the imaginary-time flow map
	TimeFlowMap(tsm, slice_shift, Q, tau, d, T);

	// form the matrix D_b^{-1}
	__assume_aligned(G, MEM_DATA_ALIGN);
	memset(G, 0, N*N * sizeof(double));
	int i;
	#pragma ivdep
	for (i = 0; i < N; i++)
	{
		G[i + i*N] = (fabs(d[i]) > 1.0 ? 1.0 / d[i] : 1.0);
	}
	// calculate D_b^{-1} Q^T
	LAPACKE_dormqr(LAPACK_COL_MAJOR, 'R', 'T', N, N, N, Q, N, tau, G, N);

	// calculate D_s T and store result in T
	for (i = 0; i < N; i++)
	{
		if (fabs(d[i]) <= 1.0)
		{
			cblas_dscal(N, d[i], &T[i], N);
		}
	}

	// calculate D_b^{-1} Q^T + D_s T, store result in T
	cblas_daxpy(N*N, 1.0, G, 1, T, 1);

	// perform a LU decomposition of D_b^{-1} Q^T + D_s T
	lapack_int *ipiv = MKL_malloc(N * sizeof(lapack_int), MEM_DATA_ALIGN);
	LAPACKE_dgetrf(LAPACK_COL_MAJOR, N, N, T, N, ipiv);

	// calculate (D_b^{-1} Q^T + D_s T)^{-1} (D_b^{-1} Q^T)
	LAPACKE_dgetrs(LAPACK_COL_MAJOR, 'N', N, N, T, N, ipiv, G, N);

	// clean up
	MKL_free(ipiv);
	MKL_free(T);
	MKL_free(d);
	MKL_free(tau);
	MKL_free(Q);
}


//________________________________________________________________________________________________________________________
///
/// \brief Update the Green's function matrix after a spin flip or phonon update, using the Sherman-Morrison formula
///
void GreenShermanMorrisonUpdate(const double delta, const int N, const int i, double *restrict G)
{
	__assume_aligned(G, MEM_DATA_ALIGN);

	int j;

	// copy and scale i-th row of G
	double *c = (double *)MKL_malloc(N * sizeof(double), MEM_DATA_ALIGN);
	__assume_aligned(c, MEM_DATA_ALIGN);
	for (j = 0; j < N; j++)
	{
		c[j] = -delta * G[i + j*N];
	}
	c[i] += delta;

	// copy and scale i-th column of G
	double *d = (double *)MKL_malloc(N * sizeof(double), MEM_DATA_ALIGN);
	__assume_aligned(d, MEM_DATA_ALIGN);
	const double inv1ci = 1 / (1 + c[i]);
	for (j = 0; j < N; j++)
	{
		d[j] = inv1ci * G[j + N*i];
	}

	// subtract Kronecker product of d and c from G
	for (j = 0; j < N; j++)
	{
		int k;
		for (k = 0; k < N; k++)
		{
			G[k + N*j] -= d[k] * c[j];
		}
	}

	// clean up
	MKL_free(d);
	MKL_free(c);
}


//________________________________________________________________________________________________________________________
///
/// \brief Perform the operation B_l G B_l^{-1} with B_l an imaginary-time step generated by the Hamiltonian
///
void GreenTimeSliceWrap(const int N, const double *restrict B, const double *restrict invB, double *restrict G)
{
	// temporary matrix
	double *T = (double *)MKL_malloc(N*N * sizeof(double), MEM_DATA_ALIGN);

	// compute B * G
	cblas_dgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, N, N, N, 1.0, B, N, G, N, 0.0, T, N);

	// compute (B * G) * B^{-1}, store result in G
	cblas_dgemm(CblasColMajor, CblasNoTrans, CblasNoTrans, N, N, N, 1.0, T, N, invB, N, 0.0, G, N);

	// clean up
	MKL_free(T);
}
